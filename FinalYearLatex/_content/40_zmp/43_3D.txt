The method for generating a ZMP reference trajectory, $\mathbf{y_d^*}$, 
is covered in Section \ref{sec:NovelTraj}, thus it is simply a matter 
of simulating the discretised pendulum dynamics with the optimal input 
$\mathbf{u_d^*}$ along some predefined trajectory.

\subsubsection*{LIPM ZMP Model}

The pendulum model is initialised at zero in both $X$ and $Z$, with the 
mass constrained to move in the $XZ$ plane at $y_c = 0.5$ metres. This is depicted in
figure \ref{fig:matLIPM}, with the pendulum mass and shaft in red, while
the constraint plane is a pale red.

\begin{figure}[!h]
    \begin{center}
        \includegraphics[width=.95\linewidth]{_content/40_zmp/LIPM/LIPM_INIT.eps}
        \caption{Inverted Pendulum Initial Position}\label{fig:matLIPM}
    \end{center}
\end{figure}

The arbitrary trajectory chosen is a sinusoidal function of time, set out in equation \eqref{eq:LIPM_TRJ}, 
and is represented in black. The initial $ZMP(x,z)$, which is the first value of $\mathbf{y_d}$, is at the origin.
This is seen in figure \ref{fig:matLIPM} as the blue cross.

\begin{equation}\label{eq:LIPM_TRJ}
    \begin{aligned}
        \lambda &= 2                        \\
        \dot{x} &= 0.2                      \\
        A &= 0.25                           \\
        f &= \dot{x} \lambda^{-1}           \\
        \omega &= 2 \pi f                   \\
        \mathbf{Q}(t) &= \begin{bmatrix}
            \dot{x}t & 0 & A \cdot sin(\omega t) 
        \end{bmatrix}^{\top}
    \end{aligned}
\end{equation}

To travel along this trajectory, a step length of $0.15$ metres was used, with a footstep radius of
$0.1$ metres. This parameterisation of this footstep is similar to the full humanoid robot.
Weights $\mathbf{Q}_e$, $\mathbf{Q}_x$ and $\mathbf{R}$ were set as $\mathbf{I}_{2 \times 2}$, 
$\mathbf{0}_{6 \times 6}$ and $\mathbf{1e^{-3}}_{2 \times 2}$ respectively. The model was then 
run at $50$ Hz, with a $1$ second time horizon, for $10$ seconds.

\begin{figure}[!h]
    \begin{center}
        \includegraphics[width=.95\linewidth]{_content/40_zmp/LIPM/LIPM_50hz1sec.eps}
        \caption{Inverted Pendulum Model $\mathbf{y_d}$ vs $\mathbf{y_d^*}$, at 50Hz}\label{fig:matLIPM50a}
    \end{center}
\end{figure}

Figure \ref{fig:matLIPM50a} depicts the achieved ZMP, in red, in comparison with the ZMP reference trajectory, 
in black. Significant overshoot is clearly evident along the $Z$ axis, and exists along the $X$ axis too. This
overshoot is most evident when viewing the ZMP reference trajectory, $\mathbf{y_d^*}$, and the achieved 
ZMP trajectory, $\mathbf{y_d}$, from above.

\begin{figure}[!h]
    \begin{center}
        \includegraphics[width=.95\linewidth]{_content/40_zmp/LIPM/LIPM_50hz1sec_BIRD.eps}
        \caption{Inverted Pendulum Model view from above, at 50Hz}\label{fig:matLIPM50b}
    \end{center}
\end{figure}

Figure \ref{fig:matLIPM50b} demonstrates the impact of the aforementioned overshoot. In addition,
there is evidence of some nonlinear behaviour in the achieved ZMP trajectory. On closer inspection
of the figure, it is evident that this behaviour worsens with time. This is most apparent in the lower
half of figure \ref{fig:matLIPM50b} as the ZMP trajectory, in blue, deteriorates from an initially
linear path between ZMP reference footsteps.

Doubling the system frequency significantly reduces the ZMP error. This is evident in Figure \ref{fig:matLIPM100a},
which depicts the exactly the same model, run with the with the same time horizon, at double the frequency.
Overshoot is evident along the $Z$ and $X$ axes too, however it has been substantially reduced following the 
change in system frequency.

\begin{figure}[!h]
    \begin{center}
        \includegraphics[width=.95\linewidth]{_content/40_zmp/LIPM/LIPM_200hz1sec.eps}
        \caption{Inverted Pendulum Model $\mathbf{y_d}$ vs $\mathbf{y_d^*}$, at 100Hz}\label{fig:matLIPM100a}
    \end{center}
\end{figure}

Again this is most evident when view from above, as depicted in Figure \ref{fig:matLIPM100b}. However, this
reduction in ZMP error comes a the cost of processing time. In order to counter act the extended processing
the time horizon was reduced. To further reduce the ZMP error, the penalty on the control action, $\mathbf{R}$, 
can be reduced to allow the controller to make more violent control actions.

\begin{figure}[!h]
    \begin{center}
        \includegraphics[width=.95\linewidth]{_content/40_zmp/LIPM/LIPM_200hz1sec_BIRD.eps}
        \caption{Inverted Pendulum Model view from above, at 100Hz}\label{fig:matLIPM100b}
    \end{center}
\end{figure}

\subsubsection*{Implementation of Zero Moment Point Locomotion}

The chosen trajectory is a sinusoid with parameters found in \eqref{eq:3DZMP_TRJ}.
The wavelength, $\lambda$, is two metres, while the target axial velocity is $0.15 ms^{-1}$, and the 
amplitude of the sine wave is $0.25$ metres. This yielded frequency $f$, and angular velocity, $\omega$, 
as seen above. The floor projected CoM position, $\mathbf{r}_{CoM}$, was added so the final 
time iterated trajectory would begin from the centre of the robot.

\begin{equation}\label{eq:3DZMP_TRJ}
    \begin{aligned}
        \lambda &= 2                        \\
        \dot{x} &= 0.15                     \\
        A &= 0.25                           \\
        f &= \dot{x} \lambda^{-1}           \\
        \omega &= 2 \pi f                   \\
        \mathbf{Q}(t) &= \mathbf{r}_{CoM} + 
        \begin{bmatrix}
            \dot{x}t & 0 & A \cdot sin(\omega t) 
        \end{bmatrix}^{\top}
    \end{aligned}
\end{equation}

The model for the robot itself, [UPDATE MODELS], was initialised with the same joint value vector \eqref{eq:3D_JA_INIT}

The right foot was chosen as the global origin, and thus the left foot was designated the as 
the inital $End$ $Effector$. Finally, the system frequency was chosen as $200 Hz$, and the simulation
time, $25$ seconds. The resulting initialised robot is presented in figure \ref{fig:3DQS_init}.
Immediately evident is the partial sine wave trajectory, in black, beginning from the floor projected CoM.
To step along the trajectory a step size of $0.05$ metres and step height of $0.05$ metres were chosen.

\begin{figure}[!h]
    \begin{center}
        \includegraphics[width=.8\linewidth]{_content/40_zmp/ZMP/figZMPinit.png}
        \caption{Initialised 3D model of the NuGus Robot, with LIPM }
        \label{fig:ZMP_init}
    \end{center}
\end{figure}

To run the model, a modified version of Algorithm \ref{alg:Glb2Fts} is used. 
Algorithm \ref{alg:3DalgSimp} includes three new variables for running the model, $init$, $run$ and
$stop$. All three temporarily store indexes of the time span. Given the state of the robot
is initialised at time zero, $init$, stores this index. The algorithm then proceeds to iterate through
the global trajectory, much like algorithm \ref{alg:Glb2Fts}. However upon reaching the step magnitude, 
$StepSize$, a step trajectory, $\mathbf{Q_step}$, is generated and traversed immediately after 
determining the position of the footstep, $\mathbf{REF}_k$.

At this point, time moves forward from $\mathbf{tspan}(run)$ to $\mathbf{tspan}(stop)$. In this manner,
the outer \textbf{for} loop is merely processing in preparation for the next step. If the total 
time taken spent processing in preparation for the next step is greater than the time-step of the 
system, then the algorithm has failed. Thus, a successful implementation of this idea depends on 
efficient programming as well as computation speed.

Once the step is complete, the $init$ variable stores the $stop$ index. This is necessary to
switch between $End$ $Effector$s, that being the left and right feet, just prior to taking a subsequent step.
This switch allows the passing of the $End$ $Effector$ state vector to the step trajectory generation function.

%%\input{_content/30_quasiStatic/Alg3D_model.txt}

\subsubsection*{Matlab Simulation Results}

Figure \ref{fig:ZMP_traj} depicts the initial position of the feet, in red and blue, with respect to 
the sinusoidal trajectory, in black. The $End$ $Effector$ trajectory, shown in green, demonstrates the 
aforementioned switching nature of algorithm \ref{alg:3DalgSimp}. This trajectory begins at the 
left foot, completes a step, and then switches to the right foot. 

\begin{figure}[!h]
    \begin{center}
        \includegraphics[width=.8\linewidth]{_content/40_zmp/ZMP/figZMPtrj.png}
        \caption{ CAPTION }
        \label{fig:ZMP_traj}
    \end{center}
\end{figure}

This process bounces back and forth, 
producing the figure on the right hand side of figure \ref{fig:ZMP_traj}. In red, the path of the 
left foot, as $End$ $Effector$, is clearly visible, rising and falling with each step. The right foot,
in blue, moves in much the same manner. It is evident that the step trajectory generation algorithm
doesn't produce steps of a uniform length, however, any individual step will rarely be greater than
the established step magnitude variable. The non-uniform nature of the steps enable the `tracking' of
the sinusoidal trajectory by the robot.

\begin{figure}[!h]
    \begin{center}
        \includegraphics[width=.8\linewidth]{_content/40_zmp/ZMP/figZMPlipm.png}
        \caption{ Robot waist vec perpendicular to sinusoidal trajectory }
        \label{fig:ZMPlipm}
    \end{center}
\end{figure}

 
Finally, figure \ref{fig:3DQS_action} proves the success of this quasistatic locomotion implementation.
In pink, the path of the CoM quite clearly starts from the bounds of a former left foot support polygon during
a step by th right foot. It then converges to the centre of the right foot support polygon prior to 
the left foot leaving the ground. Finally, it clearly begins to creep forward as the left foot continues
its step. The green trajectory is that of the $End$ $Effector$, which should be reminiscent of figure 
\ref{fig:3DQS_traj}.

\begin{figure}[!h] 
    \begin{center}
        \includegraphics[width=.8\linewidth]{_content/40_zmp/ZMP/figZMPAction.png}
        \caption{ Zero Moment Point Locomotion. Time period: X - Y seconds}
        \label{fig:ZMP_action}
    \end{center}
\end{figure}